ca65 V2.19 - Git 0541b65
Main file   : init.asm
Current file: init.asm

000000r 1               OAM_ADDRESS     = $2003
000000r 1               OAM_DMA         = $4014
000000r 1               PPU_ADDRESS     = $2006
000000r 1               PPU_DATA        = $2007
000000r 1               PPU_SCROLL      = $2005
000000r 1               ;sprite_data     = $0200
000000r 1               OAM = $0200
000000r 1               
000000r 1               ;COLOR_BLACK     = #$0f
000000r 1               ;COLOR_WHITE     = #$20
000000r 1               
000000r 1               Message:
000000r 1  48 65 6C 6C  .byte "Hello World!", $00
000004r 1  6F 20 57 6F  
000008r 1  72 6C 64 21  
00000Dr 1               
00000Dr 1               .segment "ZEROPAGE"
000000r 1  xx           frame_done:     .res 1
000001r 1               
000001r 1               .segment "HEADER"
000000r 1  4E 45 53 1A  	.byte "NES",26, 2,1, 0,0
000004r 1  02 01 00 00  
000008r 1               
000008r 1               .segment "STARTUP" ; avoids warning
000000r 1               
000000r 1               reset:
000000r 1  78               sei        ; ignore IRQs
000001r 1  D8               cld        ; disable decimal mode
000002r 1  A2 40            ldx #$40
000004r 1  8E 17 40         stx $4017  ; disable APU frame IRQ
000007r 1  A2 FF            ldx #$ff
000009r 1  9A               txs        ; Set up stack
00000Ar 1  E8               inx        ; now X = 0
00000Br 1  8E 00 20         stx $2000  ; disable NMI
00000Er 1  8E 01 20         stx $2001  ; disable rendering
000011r 1  8E 10 40         stx $4010  ; disable DMC IRQs
000014r 1               
000014r 1                   ; Optional (omitted):
000014r 1                   ; Set up mapper and jmp to further init code here.
000014r 1               
000014r 1                   ; The vblank flag is in an unknown state after reset,
000014r 1                   ; so it is cleared here to make sure that @vblankwait1
000014r 1                   ; does not exit immediately.
000014r 1  2C 02 20         bit $2002
000017r 1               
000017r 1                   ; First of two waits for vertical blank to make sure that the
000017r 1                   ; PPU has stabilized
000017r 1               @vblankwait1:
000017r 1  2C 02 20         bit $2002
00001Ar 1  10 FB            bpl @vblankwait1
00001Cr 1               
00001Cr 1                   ; We now have about 30,000 cycles to burn before the PPU stabilizes.
00001Cr 1                   ; One thing we can do with this time is put RAM in a known state.
00001Cr 1                   ; Here we fill it with $00, which matches what (say) a C compiler
00001Cr 1                   ; expects for BSS.  Conveniently, X is still 0.
00001Cr 1  8A               txa
00001Dr 1               @clrmem:
00001Dr 1  95 00            sta $000,x
00001Fr 1  9D 00 01         sta $100,x
000022r 1  9D 00 02         sta $200,x
000025r 1  9D 00 03         sta $300,x
000028r 1  9D 00 04         sta $400,x
00002Br 1  9D 00 05         sta $500,x
00002Er 1  9D 00 06         sta $600,x
000031r 1  9D 00 07         sta $700,x
000034r 1  E8               inx
000035r 1  D0 E6            bne @clrmem
000037r 1               
000037r 1                   ; Other things you can do between vblank waits are set up audio
000037r 1                   ; or set up other mapper registers.
000037r 1               
000037r 1               @vblankwait2:
000037r 1  2C 02 20         bit $2002
00003Ar 1  10 FB            bpl @vblankwait2
00003Cr 1               
00003Cr 1               ; initialize PPU OAM
00003Cr 1               ;ldx #$00
00003Cr 1               ;stx OAM_ADDRESS ; $00
00003Cr 1               ;lda #$02 ; use page $0200-$02ff
00003Cr 1               ;sta OAM_DMA
00003Cr 1               
00003Cr 1  20 rr rr     jsr load_palette
00003Fr 1               
00003Fr 1  A9 21        lda #$21
000041r 1  8D 06 20     sta PPU_ADDRESS
000044r 1  A9 CA        lda #$ca
000046r 1  8D 06 20     sta PPU_ADDRESS
000049r 1               
000049r 1               ; Loop:
000049r 1               ;     LDA Message,X     ; Load the byte at Message + X into A
000049r 1               ;     BEQ Done          ; If it's the null terminator, jump to Done
000049r 1               ;     STA PPU_DATA       ; Store the byte in memory at $0200 + Y
000049r 1               ;     INX               ; Increment X to point to the next character in the string
000049r 1               ;     ;INY               ; Increment Y to point to the next memory location
000049r 1               ;     JMP Loop          ; Repeat the loop
000049r 1               
000049r 1               ; Done:
000049r 1               
000049r 1               ; reset scroll location to top-left of screen
000049r 1  A9 00        lda #$00
00004Br 1  8D 05 20     sta PPU_SCROLL
00004Er 1  8D 05 20     sta PPU_SCROLL
000051r 1               
000051r 1  A9 C0        lda #$c0
000053r 1  8D 00 02     sta $0200
000056r 1  A9 43        lda #$43
000058r 1  8D 01 02     sta $0201
00005Br 1  A9 06        lda #%00000110
00005Dr 1  8D 02 02     sta $0202
000060r 1  A9 05        lda #$05
000062r 1  8D 03 02     sta $0203
000065r 1               
000065r 1               ; Set up OAMADDR
000065r 1  A9 00        lda #<OAM   ; Low byte of sprite_data address
000067r 1  8D 03 20     sta OAM_ADDRESS           ; Store low byte into OAMADDR
00006Ar 1               
00006Ar 1  A9 20        lda #$20            ; High byte of sprite_data address
00006Cr 1  8D 03 20     sta OAM_ADDRESS           ; Store high byte into OAMADDR
00006Fr 1               
00006Fr 1               ; Trigger OAMDMA transfer
00006Fr 1               ;lda #%00000001      ; Any non-zero value will initiate DMA transfer
00006Fr 1               ;sta $4014           ; Start DMA transfer to OAM (this transfers all sprite data - 256 bytes - from CPU memory to PPU memory)
00006Fr 1               
00006Fr 1  A9 80        lda #$80
000071r 1               ;lda #%10000000
000071r 1               ;inx        ; now X = 1
000071r 1  8D 00 20     sta $2000  ; enable NMI
000074r 1  A9 1E        lda #$1e
000076r 1  8D 01 20     sta $2001  ; enable rendering
000079r 1  A9 FF        lda #$ff
00007Br 1  8D 10 40     sta $4010  ; enable DMC IRQs
00007Er 1               
00007Er 1               @loop:
00007Er 1               	;ldx #$0
00007Er 1               	;@loop2:
00007Er 1               		; lda #$cf
00007Er 1               		;txa
00007Er 1               		;sta $000, x
00007Er 1               		;inx
00007Er 1               		;cpx #$a
00007Er 1               		;bne @loop2
00007Er 1               	;inc $00
00007Er 1  20 rr rr         jsr wait_frame
000081r 1                   ;inc $00
000081r 1  EE 03 02         inc $0203
000084r 1  4C rr rr     jmp @loop
000087r 1               
000087r 1               ;palette = $0000
000087r 1               
000087r 1               .proc wait_frame
000087r 1  E6 rr            inc frame_done          ; Make it non-zero
000089r 1                   @loop:
000089r 1  A5 rr                lda frame_done
00008Br 1  D0 FC                bne @loop           ; Wait for frame_done to become zero again
00008Dr 1  60                   rts
00008Er 1               .endproc
00008Er 1               
00008Er 1               .proc load_palette
00008Er 1  A9 3F            lda #$3f
000090r 1  8D 06 20         sta PPU_ADDRESS
000093r 1  A9 00            lda #$00
000095r 1  8D 06 20         sta PPU_ADDRESS
000098r 1                   ; load 8 palettes (4 bg, 4 sprite)
000098r 1  A6 08            ldx 8
00009Ar 1                   palette_loop:
00009Ar 1                       ;ldx 0
00009Ar 1  A9 0F                lda #$0f ; black
00009Cr 1  8D 07 20             sta PPU_DATA
00009Fr 1  A9 20                lda #$20 ; white
0000A1r 1  8D 07 20             sta PPU_DATA
0000A4r 1  8D 07 20             sta PPU_DATA
0000A7r 1  8D 07 20             sta PPU_DATA
0000AAr 1  CA                   dex
0000ABr 1  D0 ED                bne palette_loop
0000ADr 1  60               rts
0000AEr 1               .endproc
0000AEr 1               
0000AEr 1               .proc nmi
0000AEr 1                   ; Define RGB values for a sprite palette (example)
0000AEr 1                   ;palette:
0000AEr 1               
0000AEr 1               	;sta $00, x
0000AEr 1               
0000AEr 1               
0000AEr 1                   ; Load palette into PPU registers
0000AEr 1                   ;ldx #$0              ; Start with color 0
0000AEr 1                   ;lda #$55       ; Load first color (RGB values)
0000AEr 1                   ;sta $3F00,x         ; Store in PPU palette register
0000AEr 1                   ;inx                 ; Increment index
0000AEr 1                   ;lda $0000,x       ; Load second color (RGB values)
0000AEr 1                   ;sta $3F00,x         ; Store in PPU palette register
0000AEr 1                   ;inx                 ; Increment index
0000AEr 1                   ;lda $0000,x       ; Load third color (RGB values)
0000AEr 1                   ;sta $3F00,x         ; Store in PPU palette register
0000AEr 1                   ;inx                 ; Increment index
0000AEr 1                   ;lda $0000,x       ; Load fourth color (RGB values)
0000AEr 1                   ;sta $3F00,x         ; Store in PPU palette register
0000AEr 1               
0000AEr 1                   ; Example of setting palette for sprites (PPU address $3F10-$3F1F)
0000AEr 1                   ;ldx #$0              ; Start with color 0
0000AEr 1                   ;lda $0000,x       ; Load first color (RGB values)
0000AEr 1                   ;sta $3F10,x         ; Store in PPU palette register (sprite palette)
0000AEr 1                   ;inx                 ; Increment index
0000AEr 1                   ;lda $0000,x       ; Load second color (RGB values)
0000AEr 1                   ;sta $3F10,x         ; Store in PPU palette register (sprite palette)
0000AEr 1                   ;inx                 ; Increment index
0000AEr 1                   ;lda $0000,x       ; Load third color (RGB values)
0000AEr 1                   ;sta $3F10,x         ; Store in PPU palette register (sprite palette)
0000AEr 1                   ;inx                 ; Increment index
0000AEr 1                   ;lda $0000,x       ; Load fourth color (RGB values)
0000AEr 1                   ;sta $3F10,x         ; Store in PPU palette register (sprite palette)
0000AEr 1               
0000AEr 1                   ; Set up OAMADDR
0000AEr 1                   ;lda #<OAM   ; Low byte of sprite_data address
0000AEr 1                   ;sta OAM_ADDRESS           ; Store low byte into OAMADDR
0000AEr 1               
0000AEr 1                   ;lda #$20            ; High byte of sprite_data address
0000AEr 1  A9 00            lda #$0                     ; Start writing at OAM_ADDRESS 0 in the PPU
0000B0r 1  8D 03 20         sta OAM_ADDRESS           ; Store high byte into OAMADDR
0000B3r 1  A9 02            lda #>OAM                   ; Store high byte into OAM_DMA
0000B5r 1  8D 14 40         sta OAM_DMA
0000B8r 1               
0000B8r 1  A9 00            lda #$0
0000BAr 1  85 rr            sta frame_done      ; Ding fries are done
0000BCr 1               
0000BCr 1                   ; Wait for DMA transfer to complete (optional)
0000BCr 1                   ;wait_dma:
0000BCr 1                       ;bit $2002       ; Check if DMA transfer is still in progress
0000BCr 1                       ;bpl wait_dma    ; Wait until DMA transfer completes
0000BCr 1  40           	rti
0000BDr 1               .endproc
0000BDr 1               
0000BDr 1               .segment "VECTORS"
000000r 1  rr rr rr rr  	.addr nmi, reset, 0
000004r 1  00 00        
000006r 1               
000006r 1               .segment "CHR_BANK_0"
000000r 1  00 00 00 00      .incbin "sprites.chr"
000004r 1  00 00 00 00  
000008r 1  00 00 00 00  
000000r 1               
