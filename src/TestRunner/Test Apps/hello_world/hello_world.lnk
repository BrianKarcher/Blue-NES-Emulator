ca65 V2.19 - Git 0541b65
Main file   : init.asm
Current file: init.asm

000000r 1               OAM_ADDRESS     = $2003
000000r 1               OAM_DMA         = $4014
000000r 1               PPU_ADDRESS     = $2006
000000r 1               PPU_DATA        = $2007
000000r 1               PPU_SCROLL      = $2005
000000r 1               ;sprite_data     = $0200
000000r 1               OAM = $0200
000000r 1               
000000r 1               ;COLOR_BLACK     = #$0f
000000r 1               ;COLOR_WHITE     = #$20
000000r 1               
000000r 1               Message:
000000r 1  48 65 6C 6C  .byte "Hello World!", $00
000004r 1  6F 20 57 6F  
000008r 1  72 6C 64 21  
00000Dr 1               
00000Dr 1               .segment "ZEROPAGE"
000000r 1  xx           frame_done:     .res 1
000001r 1               
000001r 1               .segment "HEADER"
000000r 1  4E 45 53 1A  	.byte "NES",26, 2,1, 0,0
000004r 1  02 01 00 00  
000008r 1               
000008r 1               .segment "STARTUP" ; avoids warning
000000r 1               
000000r 1               reset:
000000r 1  78               sei        ; ignore IRQs
000001r 1  D8               cld        ; disable decimal mode
000002r 1  A2 40            ldx #$40
000004r 1  8E 17 40         stx $4017  ; disable APU frame IRQ
000007r 1  A2 FF            ldx #$ff
000009r 1  9A               txs        ; Set up stack
00000Ar 1  E8               inx        ; now X = 0
00000Br 1  8E 00 20         stx $2000  ; disable NMI
00000Er 1  8E 01 20         stx $2001  ; disable rendering
000011r 1  8E 10 40         stx $4010  ; disable DMC IRQs
000014r 1               
000014r 1                   ; Optional (omitted):
000014r 1                   ; Set up mapper and jmp to further init code here.
000014r 1               
000014r 1                   ; The vblank flag is in an unknown state after reset,
000014r 1                   ; so it is cleared here to make sure that @vblankwait1
000014r 1                   ; does not exit immediately.
000014r 1  2C 02 20         bit $2002
000017r 1               
000017r 1                   ; First of two waits for vertical blank to make sure that the
000017r 1                   ; PPU has stabilized
000017r 1               @vblankwait1:
000017r 1  2C 02 20         bit $2002
00001Ar 1  10 FB            bpl @vblankwait1
00001Cr 1               
00001Cr 1                   ; We now have about 30,000 cycles to burn before the PPU stabilizes.
00001Cr 1                   ; One thing we can do with this time is put RAM in a known state.
00001Cr 1                   ; Here we fill it with $00, which matches what (say) a C compiler
00001Cr 1                   ; expects for BSS.  Conveniently, X is still 0.
00001Cr 1  8A               txa
00001Dr 1               @clrmem:
00001Dr 1  95 00            sta $000,x
00001Fr 1  9D 00 01         sta $100,x
000022r 1  9D 00 02         sta $200,x
000025r 1  9D 00 03         sta $300,x
000028r 1  9D 00 04         sta $400,x
00002Br 1  9D 00 05         sta $500,x
00002Er 1  9D 00 06         sta $600,x
000031r 1  9D 00 07         sta $700,x
000034r 1  E8               inx
000035r 1  D0 E6            bne @clrmem
000037r 1               
000037r 1                   ; Other things you can do between vblank waits are set up audio
000037r 1                   ; or set up other mapper registers.
000037r 1  20 rr rr         jsr clear_nametable
00003Ar 1               
00003Ar 1               @vblankwait2:
00003Ar 1  2C 02 20         bit $2002
00003Dr 1  10 FB            bpl @vblankwait2
00003Fr 1               
00003Fr 1               ; initialize PPU OAM
00003Fr 1               ;ldx #$00
00003Fr 1               ;stx OAM_ADDRESS ; $00
00003Fr 1               ;lda #$02 ; use page $0200-$02ff
00003Fr 1               ;sta OAM_DMA
00003Fr 1               
00003Fr 1  20 rr rr     jsr load_palette
000042r 1               
000042r 1  A9 21        lda #$21
000044r 1  8D 06 20     sta PPU_ADDRESS
000047r 1  A9 CA        lda #$ca
000049r 1  8D 06 20     sta PPU_ADDRESS
00004Cr 1               
00004Cr 1               Loop:
00004Cr 1  BD rr rr         LDA Message,X     ; Load the byte at Message + X into A
00004Fr 1  F0 07            BEQ Done          ; If it's the null terminator, jump to Done
000051r 1  8D 07 20         STA PPU_DATA       ; Store the byte in memory at $0200 + Y
000054r 1  E8               INX               ; Increment X to point to the next character in the string
000055r 1                   ;INY               ; Increment Y to point to the next memory location
000055r 1  4C rr rr         JMP Loop          ; Repeat the loop
000058r 1               
000058r 1               Done:
000058r 1               
000058r 1               ; reset scroll location to top-left of screen
000058r 1  A9 00        lda #$00
00005Ar 1  8D 05 20     sta PPU_SCROLL
00005Dr 1  8D 05 20     sta PPU_SCROLL
000060r 1               
000060r 1               ; lda #$c0
000060r 1               ; sta $0200
000060r 1               ; lda #$43
000060r 1               ; sta $0201
000060r 1               ; lda #%00000110
000060r 1               ; sta $0202
000060r 1               ; lda #$05
000060r 1               ; sta $0203
000060r 1               
000060r 1               ; Set up OAMADDR
000060r 1               ; lda #<OAM   ; Low byte of sprite_data address
000060r 1               ; sta OAM_ADDRESS           ; Store low byte into OAMADDR
000060r 1               
000060r 1               ; lda #$20            ; High byte of sprite_data address
000060r 1               ; sta OAM_ADDRESS           ; Store high byte into OAMADDR
000060r 1               
000060r 1               ; Trigger OAMDMA transfer
000060r 1               ;lda #%00000001      ; Any non-zero value will initiate DMA transfer
000060r 1               ;sta $4014           ; Start DMA transfer to OAM (this transfers all sprite data - 256 bytes - from CPU memory to PPU memory)
000060r 1               
000060r 1  A9 80        lda #$80
000062r 1               ;lda #%10000000
000062r 1               ;inx        ; now X = 1
000062r 1  8D 00 20     sta $2000  ; enable NMI
000065r 1  A9 1E        lda #$1e
000067r 1  8D 01 20     sta $2001  ; enable rendering
00006Ar 1  A9 FF        lda #$ff
00006Cr 1  8D 10 40     sta $4010  ; enable DMC IRQs
00006Fr 1               
00006Fr 1               @loop:
00006Fr 1               	;ldx #$0
00006Fr 1               	;@loop2:
00006Fr 1               		; lda #$cf
00006Fr 1               		;txa
00006Fr 1               		;sta $000, x
00006Fr 1               		;inx
00006Fr 1               		;cpx #$a
00006Fr 1               		;bne @loop2
00006Fr 1               	;inc $00
00006Fr 1  20 rr rr         jsr wait_frame
000072r 1                   ;inc $00
000072r 1                   ; inc $0203
000072r 1  4C rr rr     jmp @loop
000075r 1               
000075r 1               ;palette = $0000
000075r 1               
000075r 1               .proc wait_frame
000075r 1  E6 rr            inc frame_done          ; Make it non-zero
000077r 1                   @loop:
000077r 1  A5 rr                lda frame_done
000079r 1  D0 FC                bne @loop           ; Wait for frame_done to become zero again
00007Br 1  60                   rts
00007Cr 1               .endproc
00007Cr 1               
00007Cr 1               .proc load_palette
00007Cr 1  A9 3F            lda #$3f
00007Er 1  8D 06 20         sta PPU_ADDRESS
000081r 1  A9 00            lda #$00
000083r 1  8D 06 20         sta PPU_ADDRESS
000086r 1                   ; load 8 palettes (4 bg, 4 sprite)
000086r 1  A2 08            ldx #$08
000088r 1                   palette_loop:
000088r 1                       ;ldx 0
000088r 1  A9 0F                lda #$0f ; black
00008Ar 1  8D 07 20             sta PPU_DATA
00008Dr 1  A9 20                lda #$20 ; white
00008Fr 1  8D 07 20             sta PPU_DATA
000092r 1  8D 07 20             sta PPU_DATA
000095r 1  8D 07 20             sta PPU_DATA
000098r 1  CA                   dex
000099r 1  D0 ED                bne palette_loop
00009Br 1  60               rts
00009Cr 1               .endproc
00009Cr 1               
00009Cr 1               .proc nmi
00009Cr 1                   ; Define RGB values for a sprite palette (example)
00009Cr 1                   ;palette:
00009Cr 1               
00009Cr 1               	;sta $00, x
00009Cr 1               
00009Cr 1               
00009Cr 1                   ; Load palette into PPU registers
00009Cr 1                   ;ldx #$0              ; Start with color 0
00009Cr 1                   ;lda #$55       ; Load first color (RGB values)
00009Cr 1                   ;sta $3F00,x         ; Store in PPU palette register
00009Cr 1                   ;inx                 ; Increment index
00009Cr 1                   ;lda $0000,x       ; Load second color (RGB values)
00009Cr 1                   ;sta $3F00,x         ; Store in PPU palette register
00009Cr 1                   ;inx                 ; Increment index
00009Cr 1                   ;lda $0000,x       ; Load third color (RGB values)
00009Cr 1                   ;sta $3F00,x         ; Store in PPU palette register
00009Cr 1                   ;inx                 ; Increment index
00009Cr 1                   ;lda $0000,x       ; Load fourth color (RGB values)
00009Cr 1                   ;sta $3F00,x         ; Store in PPU palette register
00009Cr 1               
00009Cr 1                   ; Example of setting palette for sprites (PPU address $3F10-$3F1F)
00009Cr 1                   ;ldx #$0              ; Start with color 0
00009Cr 1                   ;lda $0000,x       ; Load first color (RGB values)
00009Cr 1                   ;sta $3F10,x         ; Store in PPU palette register (sprite palette)
00009Cr 1                   ;inx                 ; Increment index
00009Cr 1                   ;lda $0000,x       ; Load second color (RGB values)
00009Cr 1                   ;sta $3F10,x         ; Store in PPU palette register (sprite palette)
00009Cr 1                   ;inx                 ; Increment index
00009Cr 1                   ;lda $0000,x       ; Load third color (RGB values)
00009Cr 1                   ;sta $3F10,x         ; Store in PPU palette register (sprite palette)
00009Cr 1                   ;inx                 ; Increment index
00009Cr 1                   ;lda $0000,x       ; Load fourth color (RGB values)
00009Cr 1                   ;sta $3F10,x         ; Store in PPU palette register (sprite palette)
00009Cr 1               
00009Cr 1                   ; Set up OAMADDR
00009Cr 1                   ;lda #<OAM   ; Low byte of sprite_data address
00009Cr 1                   ;sta OAM_ADDRESS           ; Store low byte into OAMADDR
00009Cr 1               
00009Cr 1                   ;lda #$20            ; High byte of sprite_data address
00009Cr 1                   ; lda #$0                     ; Start writing at OAM_ADDRESS 0 in the PPU
00009Cr 1                   ; sta OAM_ADDRESS           ; Store high byte into OAMADDR
00009Cr 1                   ; lda #>OAM                   ; Store high byte into OAM_DMA
00009Cr 1                   ; sta OAM_DMA
00009Cr 1               
00009Cr 1  A9 00            lda #$0
00009Er 1  85 rr            sta frame_done      ; Ding fries are done
0000A0r 1               
0000A0r 1                   ; Wait for DMA transfer to complete (optional)
0000A0r 1                   ;wait_dma:
0000A0r 1                       ;bit $2002       ; Check if DMA transfer is still in progress
0000A0r 1                       ;bpl wait_dma    ; Wait until DMA transfer completes
0000A0r 1  40           	rti
0000A1r 1               .endproc
0000A1r 1               
0000A1r 1               clear_nametable:
0000A1r 1               ; Example: Clear nametables
0000A1r 1  A9 20            LDA #$20        ; start at $2000
0000A3r 1  8D 06 20         STA $2006
0000A6r 1  A9 00            LDA #$00
0000A8r 1  8D 06 20         STA $2006
0000ABr 1               
0000ABr 1  A9 00            LDA #$00        ; value to clear with
0000ADr 1  A0 10            LDY #$10        ; 4 KB / 256 bytes per page = 16 pages
0000AFr 1               ClearLoop:
0000AFr 1  A2 00            LDX #$00
0000B1r 1               PageLoop:
0000B1r 1  8D 07 20         STA $2007
0000B4r 1  E8               INX
0000B5r 1  D0 FA            BNE PageLoop
0000B7r 1  88               DEY
0000B8r 1  D0 F5            BNE ClearLoop
0000BAr 1  60               RTS
0000BBr 1               
0000BBr 1               
0000BBr 1               .segment "VECTORS"
000000r 1  rr rr rr rr  	.addr nmi, reset, 0
000004r 1  00 00        
000006r 1               
000006r 1               .segment "CHR_BANK_0"
000000r 1  00 00 00 00      .incbin "sprites.chr"
000004r 1  00 00 00 00  
000008r 1  00 00 00 00  
000000r 1               
